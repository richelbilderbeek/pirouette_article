\begin{abstract}

  \textbf{1. }
    Phylogenetic trees are current routinely reconstructed from an alignment 
    of character sequences (usually nucleotide sequences). 
    Bayesian tools, such as MrBayes, RevBayes and BEAST2, 
    have gained much popularity over the last decade, 
    as they allow joint estimation of the posterior distribution of the 
    phylogenetic tree and the parameters of the underlying inference model.  
    An important ingredient of these Bayesian approaches is the species tree 
    prior. While in principle the Bayesian framework allows for comparing 
    different species tree priors and hence may elucidate the macroevolutionary 
    processes underlying the species tree, in practice only 
    macroevolutionary models that allow for fast computation of the prior 
    probability are used. 
    An open question is, how accurate the tree estimation is
    when the real macroevolutionary processes are substantially different 
    from those assumed in the tree prior. \\
  \textbf{2. }
    Here we present \verb;pirouette;, 
    a free, libre and open-source R package that assesses 
    the inference error made by Bayesian phylogenetics for a given 
    macroevolutionary diversification model. \verb;pirouette; makes use of 
    BEAST2, but its philosophy applies to any Bayesian phylogenetic inference 
    tool. \\
  \textbf{3. }
    We describe \verb;pirouette;'s usage and the biological scientific
    question it can answer, including full examples. \\
  \textbf{4. }
    Last, we discuss the results obtained by the examples and their 
    interpretation. \\
\end{abstract}

{\bf Keywords:} Bayesian model selection, BEAST2, computational biology, evolution, phylogenetics, R, tree prior

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The development of new powerful Bayesian phylogenetic inference tools, 
such as BEAST [\cite{drummond2007beast}], 
MrBayes [\cite{huelsenbeck2001mrbayes}]
or RevBayes [\cite{hohna2016revbayes}], 
has been a major advance in constructing phylogenetic trees 
from character data (usually nucleotide sequences) extracted 
from extant (but also extinct) organisms, 
and hence in our understanding of the main drivers 
and modes of diversification.

BEAST [\cite{drummond2007beast}] is a typical Bayesian phylogenetics tool, 
that needs both character data and priors to infer 
a posterior distribution of phylogenies.
Specifically, for the species tree prior - which describes 
the process of diversification - 
BEAST has built-in priors such as the Yule [\cite{yule}] and 
(constant-rate) birth-death [\cite{nee1994reconstructed}] models.
These simple tree priors are most commonly used, as these 
have sufficient biological complexity, while being computationally fast.
BEAST's successor, BEAST2 [\cite{bouckaert2019beast}],
has a package manager, that allows third-party users 
to extend existing functionalities. For example, 
one can add novel diversification models by writing a BEAST2 package 
that contains the likelihood formula of a phylogeny 
under the novel diversification model, 
i.e. the prior probability of a species tree.
Many such diversification models (and their associated probability algorithms) 
have been developed, e.g., models in which diversification is 
time-dependent [\cite{nee1994reconstructed}, \cite{rabosky2008explosive}], 
or diversity-dependent [\cite{etienne2011diversity}],
or where diversification rates change for specific lineages 
and their descendants [\cite{etienne2012conceptual}, 
\cite{rabosky2014automatic}, \cite{alfaro2009nine}, 
\cite{laudanno2018sls}], models that treat speciation as a process that takes 
time [\cite{rosindell2010protracted}][\cite{etienne2012prolonging}][\cite{lambert2015reconstructed}], 
or as a burst of simultaneous branching
events [\cite{laudanno2018mbd}], or where diversification rate
depends on a trait that has two [\cite{maddison2007estimating}], 
or more [\cite{fitzjohn2012diversitree}] states,
even concealed states [\cite{beaulieu2016detecting}] 
or a combination of all these [\cite{herrera2018detecting}].
Only a few of these diversification models are available as a BEAST2 package.

When a novel diversification model is introduced,
its performance in inference should be tested.
Part of a model's performance is its ability to recover parameters 
from simulated data with known 
parameters (e.g. [\cite{etienne2014estimating}]), 
where ideally the estimated parameter values closely match 
the known/true values.

Even when a diversification model passes the procedure described above,
it is not necessarily used in Bayesian inference.
Bayesian phylogenetic inference often requires 
that the prior probability of the phylogeny 
according to the diversification model has to be computed millions of times. 
Therefore, biologically interesting but computationally expensive tree priors 
are often not implemented, and simpler priors are used instead. 
This is not necessarily problematic, when the data are very informative, 
as this will reduce the influence of the tree prior.
However, the assumption that tree prior choice is of low importance 
must first be verified.

There have been multiple attempts to investigate the importance of tree
prior choice. For example, recently Sarver et al., [\cite{sarver2019choice}] 
showed that the choice of tree prior does not 
substantially affect phylogenetic inferences of diversification rates.
Also recently, Duchene et al. [\cite{duchene2018phylodynamic}] released
a BEAST2 package to assess how well posterior predictive simulations
recover a given tree when using the standard diversification models.
These studies show how current diversification models compare
to one another, but they do not help to assess 
the importance of a new tree prior. 

Here we introduce a method to quantify the importance of a novel tree prior.
The method starts with a phylogeny generated 
by the new model. 
Next, nucleotide sequences are simulated on this phylogeny. 
Then, using the tree priors built-in into BEAST2, 
a Bayesian posterior distribution of phylogenies is inferred. 
We then compare the inferred and simulated phylogenies. 
How to properly perform this comparison forms the heart of our method.
Only new diversification models that result 
in a large discrepancy between inferred and simulated phylogenies 
will be worth the effort and computational burden 
to implement a species tree prior for in a Bayesian framework.

Our method is programmed as an R package called \verb;pirouette;.
\verb;pirouette; is built on \verb;babette; [\cite{bilderbeek2018babette}], 
which calls BEAST2 [\cite{bouckaert2019beast}]. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; is written in the R programming language (\cite{R}).
The goal of \verb;pirouette; is to quantify the importance of a tree prior.
It does so by measuring the inference error made 
for a given reconstructed phylogeny, 
simulated under a (usually novel) diversification model.
We refer to the true model that generated the given tree
as the 'generative tree model' $\mathit{p_{G}}$.
Many tree priors have a parameter setting 
for which they reduce to a standard tree prior. 
For example, a protracted birth-death model \citep{etienne2012prolonging} 
reduces to a standard birth-death model when the speciation-completion rate 
is infinite [i.e. rate $\lambda$ in \cite{etienne2014estimating}, 
eqs.~(2b) and (2c)].
When benchmarking a novel tree prior, 
one will typically construct phylogenies 
for different combinations of the diversification model's parameters, 
to assess under which scenarios the inference error cannot be neglected. 
While we recommend many replicate simulations 
when assessing a novel tree prior, 
our examples contain only one replicate 
as they are for illustrative purposes only.

\verb;pirouette; is very flexible and allows the user 
to specify a wide variety of custom settings. 
These settings can be grouped in macro-sections, 
according to how they operate in the pipeline. 
We summarize them in Table~\ref{tab:options} and Table~\ref{tab:definitions}.

Although many possible tests can be performed, 
we show the usage of \verb;pirouette; by introducing 
its features gradually, yet ending in quantifying the impact a tree prior has
in Bayesian inference.

\begin{sidewaystable}
\centering
  \begin{tabular}{|p{3.4cm}|p{9.7cm}|p{4.5cm}@{}|}
    \hline
    \centering
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \textbf{Sub-argument} & 
    \textbf{Description} &
    \textbf{Possible values} \\ 
    \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;tree_prior; &
    Macroevolutionary diversification model &
    BD, CBS, CCP, CEP, Yule \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;clock_model; &
    Clock for the DNA mutation rates &
    RLN, strict \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;site_model; &
    Nucleotide substitution model &
    GTR, HKY, JC, TN93 \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;mutation_rate; &
    Pace at which mutation occurs &
    \verb;mutation_rate; $\in \mathbb{R}_{>0}$\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;root_sequence; &
    DNA sequence at the root of the tree &
    any combination of a, c, g, t \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;model_type; &
    Criterion to select an inference model &
    Generative, Candidate \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;run_if; &
    Condition under which an inference model is used &
    Always, Best candidate \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;do_measure_evidence; &
    Sets whether or not the evidence of the model is to be computed &
    TRUE, FALSE \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;error_fun; &
    Specifies how to measure the error &
    nLTT, $|\gamma|$ \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;burn_in_fraction; &
    Specifies the percentage of initial posterior trees to discard &
    \verb;burn_in_fraction; $\in [0, 1]$\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \hline
  \end{tabular}
  \caption{
    Most important parameter options.
    BD = birth death (\cite{nee1994reconstructed}), 
    CBS = coalescent Bayesian skyline (\cite{drummond2005bayesian}), 
    CCP = coalescent constant-population, 
    CEP = coalescent exponential-population,
    Yule = pure birth model (\cite{yule}),
    RLN = relaxed log-normal clock model (\cite{drummond2006relaxed}),
    strict = strict clock model (\cite{zuckerkandl1965molecules}), 
    GTR = Generalized time-reversible model (\cite{tavare1986some}), 
    HKY = Hasegawa, Kishino and Yano (\cite{hasegawa1985dating}), 
    JC = Jukes and Cantor (\cite{jukes1969evolution}), 
    TN93 = Tamura and Nei (\cite{tamura1993estimation}).
  }
  \label{tab:options}
\bigskip

  \begin{tabular}{|@{}c|p{4cm}|p{12.2cm}|}
    \hline
    \centering
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \textbf{Symbol} &
    \textbf{Macro-argument} &
    \textbf{Description} \\
    \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{G}$ &
    Generative model &
    The full setting to produce BEAST2 input data. 
    Its core features are the tree prior $\mathit{p_{G}}$, the clock 
    model $\mathit{c_{G}}$ and the site model $\mathit{s_{G}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
    $\mathit{A}$ &
    Alignment model &
    It includes the parts of the generative model that directly affect the 
    alignment generation, like the clock model $\mathit{c_{G}}$ and 
    the site model $\mathit{s_{G}}$. Additional arguments can be provided, 
    such as the mutation rate and the root sequence. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{X_{i}}$ &
    $i$-th candidate experiment &
    Full setting for a Bayesian inference. It is made by a 
    candidate inference model $\mathit{I_{i}}$ and its 
    inference conditions $\mathit{C_{i}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{I}$ &
    Inference model &
    Phylogenetic inference model to run BEAST2. Likewise the generative model $G$, 
    its main components are the tree prior $\mathit{p_{I}}$, 
    the clock model $\mathit{c_{I}}$ and the site model $\mathit{s_{I}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{C}$ & Inference conditions & Conditions under which $\mathit{I}$ 
    is used in the inference. 
    They are composed by the model type, run condition and 
    whether to measure the evidence. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{E}$ & Error measure parameters & 
    Errors measurement setup that can be specified providing an 
    error function to measure the difference between the original phylogeny 
    and the inferred posterior. The initial part of the posterior that is 
    reckoned as not representative can be discarded using a burn-in fraction. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \iffalse
    $\mathit{T}$ & Twinning parameters & Twin tree creation procedure & 
      $\mathit{\tau_{p}}$ \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \fi
    \hline 
  \end{tabular}
  \caption{
    Definitions of terms and relative symbols used in the main text and in 
    Fig~\ref{fig:pipeline}. To run the pipeline $\mathit{A}$, $\mathit{X}$ 
    and $\mathit{E}$ must be specified. Examples can be found in 
    listings~\ref{lst:create_alignment_params}, 
    \ref{lst:create_gen_experiment_explicit} and 
    \ref{lst:create_error_measure_params}.
  }
  \label{tab:definitions}
\end{sidewaystable}

\subsection{pirouette's pipeline}
\label{subsec:pipeline}

\begin{figure}
  \centering
  \includegraphics[width = \textwidth]{workflow4.png}
  \caption{
    \texttt{pirouette} pipeline.
    The pipeline starts from a phylogeny (1a) simulated by the generative tree model 
    $\mathit{p_{G}}$.
    The phylogeny is converted to an alignment (2a) using the generative alignment model 
    $\mathit{A} = (\mathit{c_{G}}, \mathit{s_{G}})$, composed of a clock and a site model. 
    The user defines one or more experiments.
    For each candidate experiment $\mathit{X_{i}}$ 
    (a combination of inference model $\mathit{I_{i}}$ and condition $\mathit{C_{i}}$),
    if its condition $\mathit{C_{i}}$ is 
    satisfied (which can depend on the alignment), 
    the corresponding inference model $\mathit{I} = \mathit{I_{i}}$ is selected
    to be used in the next step.
    The inference models (3a) of the selected experiments use the alignment (2a) 
    to each create a Bayesian posterior of (parameter estimates and) 
    phylogenies (4a). 
    Each of the posteriors' trees is compared to the true phylogeny (1a) 
    using the error measure $\mathit{E}$, 
    resulting in an error distribution (5a). 
    Optionally, for each selected inference model a twin pipeline can be run.
    A twin phylogeny (1b) can be generated from the original 
    phylogeny (1a) using the twin tree model $\mathit{p_{t}}$, 
    selected among standard diversification models; 
    the default option is the standard birth-death model, with parameters estimated from the original phylogeny.
    A twin alignment (2b) is then simulated from the twin phylogeny 
    using clock model $\mathit{c_{G}}$ and site model $\mathit{s_{G}}$ 
    imported from the generative model. 
    The twin alignment has the same number of mutations as the original alignment.
    The twin pipeline follows the procedure of the main pipeline, 
    resulting in a twin error distribution (5b).
  }
  \label{fig:pipeline}
\end{figure}

We assume the user has a phylogeny simulated with the new diversification model. 
The pipeline to assess the error BEAST2 makes in inferring this phylogeny 
then contains the following steps:
\begin{enumerate}
  \item from the given phylogeny an alignment is simulated 
    under a known alignment model $\mathit{A}$;
  \item from this alignment, according to the specified 
    inference conditions $\mathit{C}$, 
    an inference model $\mathit{I}$ is chosen (which may differ from the 
    generative model);
  \item the inference model and the alignment are used 
    to infer a posterior distribution of phylogenies;
  \item the phylogenies in the posterior are compared with the given phylogeny 
    to estimate the error made, according to 
    the error measure $\mathit{E}$ specified by the user;
\end{enumerate}
The pipeline is visualized in Fig.~\ref{fig:pipeline}. 
There is also the option to generate a 'twin tree', 
that goes through the same pipeline. 
The utility of this twin tree will be explained below.

The first step simulates a DNA alignment from a given 
phylogeny (Fig.~\ref{fig:pipeline}, 1a $\rightarrow$ 2a)
using the DNA alignment parameters.
The DNA alignment parameters consist of 
a (DNA) root sequence, a (DNA) mutation rate, a clock model 
and a nucleotide substitution model.
The root sequence is the DNA sequence of the shared common ancestor,
and is set to four different equally-sized mononucleotide blocks by default, as this
helps interpreting the resulting alignment.
Supported nucleotide substitution model
are JC, HKY, TN and GTR. Only the strict
clock model is currently supported in this step.

The second step (Fig.~\ref{fig:pipeline}, 3)
selects one or more inference models $I$ from a set of inference 
models $I_{1},\dots,I_{n}$. 
We define an experiment $X_{i}$ as the combination of 
an inference model $I_{i}$ and the conditions $C_{i}$ 
to actually use it in the inference step.
For example, we may require that an inference
model (a combination of a tree model, clock model and site model) 
should include the generative/true tree model. 
As a second example, we may require that we have selected a set of 
candidate inference models,
of which only the best should be used in the actual inference.
In the first example, we specified the condition $C_{i}$ that this
generative model should always be run, whereas in the second example,
we specified condition $C_{i}$ that a candidate model should only be run
when it is the best.
The 'best' model is defined as the inference model with
the highest evidence (a.k.a. marginal likelihood), given the alignment 
simulated in the previous step.
The evidence for an inference model is estimated by nested 
sampling [\cite{maturana2018model}], using the \verb;NS; BEAST2 package. 
We note that scripted use of BEAST2 packages is only possible under Linux and Mac.
Windows systems can do the model comparison for shorter DNA sequences 
using the web interface of \verb;mcbette; [\cite{mcbette}].

The third step infers the posterior distributions,
using the simulated alignment (Fig.~\ref{fig:pipeline}, 2a $\rightarrow$ 4a),
and the inference models that were selected in the previous step (3). 
For each selected experiment a posterior distribution is inferred, using the 
\verb;babette; [\cite{bilderbeek2018babette}] R package which makes use of BEAST2. 
This step usually takes up most of the pipeline's computation time.

The fourth step quantifies the inference error made. 
First the burn-in fraction is removed, i.e. the first phase of the 
Markov chain Monte Carlo (MCMC) run,
which samples an unrepresentative part of state space. 
By default, \verb;pirouette; 
removes the first 10\% of the posterior.
From the remaining posterior \verb;pirouette; 
creates an error distribution, by measuring the difference
between the true tree and each of the posterior 
trees (Fig.~\ref{fig:pipeline}, 4a $\rightarrow$ 5a).
The user can specify a function to quantify the differences between
the true and posterior trees. By default, the package uses the nLTT 
statistic (\cite{janzen2015approximate}), which is the absolute difference
between the normalized lineages-through-time plots of two trees.

\subsection{Twinning}\label{subsec:twinning}

An optional step is to use the 'twinning process'.
This process, $T$, encompasses two steps:
$T_1$, that generates a 'twin tree' (Fig.~\ref{fig:pipeline}, 1b) 
and $T_2$, which generates a 'twin alignment' (Fig.~\ref{fig:pipeline}, 2b).
Both twin tree and alignment will be analyzed in the same way 
as the true tree and alignment.

We define a phylogeny $\tau$ as the combination of
branching times $\Vec{t}$ and topology $\psi$, 
and denote as $\tau_{\mathit{G}}$ the phylogeny 
produced by a (possibly non-standard) generative diversification model, 
having branching times $\Vec{t}_{\mathit{G}}$ and 
topology $\psi_{\mathit{G}}$.

The first step ($T_1$) of the twinning process creates a tree $\tau_{\mathit{T}}$
with branching times $\Vec{t}_{\mathit{T}}$ while preserving the original
topology $\psi_{\mathit{G}}$:
\begin{align}
  \tau_{\mathit{G}} = (\Vec{t}_{\mathit{G}}, \psi_{\mathit{G}}) 
  \xrightarrow[]{\mathit{T_1}} 
  \tau_{\mathit{T}} = (\Vec{t}_{\mathit{T}}, \psi_{\mathit{G}})
\end{align}
The default option for the diversification model $p_T$ is the standard birth-death model.
It is then possible to use the likelihood function 
$L_{\mathit{T}}$ for this diversification model to find the parameters $\theta^{*}_{\mathit{T}}$ 
(e.g. speciation and extinction rates, in case of a birth-death model) 
that maximize this likelihood applied 
to the true tree, conditioned on its number of tips $n_{\mathit{G}}$:
\begin{align}
    \max[L_{\mathit{T}}(\theta_{\mathit{T}}|\tau_{\mathit{G}}, n_{\mathit{G}})] 
\rightarrow \theta^{*}_{\mathit{T}}.
\end{align}
We use $\theta^{*}_{\mathit{T}}$ to simulate a number 
$n_{\mathit{T}} = n_{\mathit{G}}$ 
of branching times $\Vec{t}_{\mathit{T}}$ for the twin tree 
$\tau_{\mathit{T}}$, under the process $p_{T}$, 
while preserving the topology. We simulate the new branching times using the TESS package (\cite{TESS, hohna2016tess}).

The second step ($T_2$) of the twinning process simulates the twin alignment 
with the same clock model, site model and mutation rate 
used to simulate the original alignment. 
We also impose that, in the twin alignment, 
the total number of mutations with respect to the root sequence 
must be the same as in the true alignment in order to keep the information content 
stored in both the true and twin alignments as similar as possible. We achieve this by simply simulating twin alignments until we
obtain one that has the desired number of mutations.

The twin pipeline serves as a control: 
even when the generating and inference models are identical
(as is the case in the twin pipeline),
the inferred trees from the posterior distribution will 
still differ from the true tree, 
due to stochasticity in producing an alignment 
and to the MCMC sampling of the posterior.
The twin pipeline provides this minimum error,
because the generating and inference model match exactly.
When comparing the true and twin error distribution,
any differences will be due to the fact that true and twin phylogenies are realizations 
of different processes: one (possibly) non-standard, $p_G$, 
and one standard, $p_T$ (see Fig~\ref{fig:pipeline}).

This can be seen for both the "generative" and "candidate" model 
types (see Table~\ref{tab:options}).
If the chosen model type is "generative", 
the tree prior chosen for the twin inference will  
exactly match the model to generate the tree.
In the main pipeline, as the tree model $p_{G}$ is non-standard, 
it cannot be used in inference.
If, instead, the chosen model type is "candidate", 
the twin tree model will be included in the pool of examined models 
during the process of selection of the inference model. 

Finally, if the goal is to evaluate BEAST2's performance on a non-standard tree prior, 
the last source of stochasticity comes from phylogenies. 
In fact, a single phylogeny cannot be considered 
as fully representative of the model. 
For this reason multiple phylogenies, 
as well as an equal number of twins, 
must be considered. 
Having the error measure normalized (i.e. comprised in the interval $[0, 1]$), 
it is possible to considerate the aggregated versions of the errors distributions 
across all the runs.
Therefore, if the number of considered phylogenies is high enough, 
the comparison between the main pipeline's aggregated error distribution 
and its twin counterpart leads to a fair evaluation 
of the new tree prior with respect to the baseline error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; will be made available on CRAN from which 
it can then be easily installed:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install.packages("pirouette")
\end{lstlisting}

Until it is on CRAN, and for the most up-to-date version, 
one can download and install the package from \verb;pirouette;'s GitHub 
repository:

\begin{lstlisting}[
    language = R,
    floatplacement = ht,
    frame = single
]
remotes::install_github("richelbilderbeek/pirouette")
\end{lstlisting}
To start using \verb;pirouette;, 
load its functions in the global namespace first:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
library(pirouette)
\end{lstlisting}
Because \verb;pirouette; calls BEAST2, BEAST2 must be installed. 
This can be done from within R, using:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install_beast2()
\end{lstlisting}
For the option to select the best candidate model,
\verb;pirouette; needs the "NS" BEAST2 package [\cite{maturana2018model}].
It can be installed from within R, using:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install_beast2_pkg("NS")
\end{lstlisting}

An overview of \verb;pirouette;'s main functions is shown in 
Table~\ref{tab:functions}. 
Their usage is demonstrated in the example code below.
All \verb;pirouette;'s functions are documented,
have a useful example and sensible defaults.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[h]
  \centering
  \begin{tabular}{ | l | l | l | }
    \hline
    \textbf{Name} & \textbf{Description} & \textbf{Listing} \\
    \hline
    \verb;pir_run; & Run \verb;pirouette; & \ref{lst:pir_run} \\
    \verb;pir_plot; & Show the \verb;pirouette; results as a plot & \ref{lst:pir_plot} \\
    \verb;create_pir_params; & Create the \verb;pirouette; parameters & \ref{lst:create_pir_params} \\
    \hline
    \verb;create_alignment_params; & Create the alignment parameters & \ref{lst:create_alignment_params} \\
    \verb;create_twinning_params; & Create the twinning parameters & \ref{lst:create_twinning_params} \\
    \verb;create_experiment; & Create one experiment & \ref{lst:create_gen_experiment_explicit} \\
    \verb;create_error_measure_params; & Create the error measurement parameters & \ref{lst:create_error_measure_params} \\
    \hline
  \end{tabular}
  \caption{
    \texttt{pirouette}'s main functions, description and the number of the 
    listing in which it is used. 
  }
  \label{tab:functions}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Usage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We show the usage of \verb;pirouette; by gradually introducing
its features.
First, to get an idea of the baseline error, 
we measure the Bayesian inference error when we start from a phylogeny 
generated under a known and standard tree model.
Second, to establish that the true tree prior is indeed the best, 
we also measure the inference error made by a
best candidate inference model.
Lastly, we quantify the impact of the tree prior in the Bayesian inference. 
We do so by separating the baseline error from the complete error 
running the pipeline starting from a tree generated by a non-standard tree model.

All the figures shown in this section are shown as-is, without any
aesthetical modifications. Figures showing the full workflow 
and tables showing the effective sample sized (a measure
of inference quality) can be found in the supplementary materials.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The generative and inference models are equal and standard.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; quantifies the influence of a new tree prior on BEAST2's 
inference by measuring the discrepancy between a given/true tree and a posterior 
distribution of phylogenies obtained as result of the inference process. 
Due to stochasticity, posterior trees will generally differ from the given 
phylogeny $\tau_{\mathit{G}}$, even when the tree 
prior and alignment model used for inference are the same as those 
used to generate the alignment.
Measuring this difference allows us to know the baseline error
of the \verb;pirouette; pipeline. We therefore define as 'standard tree priors' 
all the tree priors that are available 
to be used within an inference model (see Table~\ref{tab:options}).

Now we can formulate the first example research question that \verb;pirouette; 
can answer: "What is the inference error made on phylogenies created by a 
standard diversification model?"

In this example we use a standard generative tree model $\mathit{p_{G}^0}$, 
namely the Yule (pure-birth) tree model. 
We choose to use a small tree with six taxa, to keep
the calculations short and the figure more readable.
We pick a crown age of ten time units. This value is 
completely arbitrary, but it ties in with the mutation rate 
used in simulating an alignment in the next step.

\begin{lstlisting}[
    language = R,
    floatplacement = ht,
    frame = single, 
    label = {lst:create_yule_tree}, 
    caption = {
      Create a Yule tree. 
      The resulting tree is shown in Figure~\ref{fig:yule_tree}.
    }
  ]
phylogeny <- create_yule_tree(n_taxa = 6, crown_age = 10)
\end{lstlisting}

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{pirouette_example_1/example_1_314/true_tree.png}
  \caption{The Yule tree, as created by Listing~\ref{lst:create_yule_tree}.}
  \label{fig:yule_tree}
\end{figure}

The first step in \verb;pirouette; is to simulate a DNA alignment from the 
given phylogeny, as described in Subsection~\ref{subsec:pipeline}.
In this example, the root sequence consists of four blocks of 250 
mononucleotides each, while the per-nucleotide mutation rate is 
0.1 mutations per unit time.
We use a Jukes-Cantor (JC, \cite{jukes1969evolution}) nucleotide substitution model
and a strict clock model as these are the simplest.
A JC model assumes that mutation rates between nucleotides are equal and 
constant. 
A strict clock model assumes that the mutation rates 
of all lineages are equal and constant.

\begin{lstlisting}[
    language = R,
    floatplacement = ht,
    frame = single,
    label = {lst:create_alignment_params}, 
    caption = {Create an alignment.}
  ]
alignment_params <- create_alignment_params(
  sim_tral_fun = get_sim_tral_with_std_nsm_fun(
    mutation_rate = 0.1,
    site_model = create_jc69_site_model()
  ),
  root_sequence = create_blocked_dna(length = 1000)
)
\end{lstlisting}

As the site and clock models used here are also the defaults, 
the function arguments can be safely omitted: we just explicitly show 
them for the sake of clarity.

In the second step we state our experiment.
We define an experiment $\mathit{X}$ as a combination of an inference model 
$\mathit{I}$ and conditions $\mathit{C}$.
In this example we choose $\mathit{I}$ to be the same inference model as 
the generative one,
i.e. the Yule tree prior $\mathit{p_{G}^0}$ and site 
and clock models defined in $\mathit{A}$, 
respectively Jukes-Cantor and strict clock.
We specify in $\mathit{C}$ that the experiment will always be run.

\begin{table}
  \begin{tabular}{ | c | c | c | l | }
    \hline
    \texttt{model\_type} &
    \texttt{run\_if} &
    \texttt{do\_measure\_evidence} & 
    \texttt{inference model} \\ 
    \hline
    generative &
    always &
    FALSE &
    JC, strict, Yule \\
    \hline
  \end{tabular}
  \caption{
    Inference conditions and model.
    JC: Jukes-Cantor nucleotide substitution model.
    strict: strict clock model.
    Yule: Yule (pure-birth) tree prior.
  }
  \label{tab:RQ1}
\end{table}

Listing~\ref{lst:create_gen_experiment_explicit} shows how to
set up this experiment:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_gen_experiment_explicit},
  caption = {
    Create an experiment with the generative model,
    that will always be used in the actual inference, 
    using explicit arguments.
  }
]
generative_experiment <- create_experiment(
  inference_conditions = create_inference_conditions(
    model_type = "generative", 
    run_if = "always"
  ), 
  inference_model = create_inference_model(
    tree_prior = create_yule_tree_prior(),
    clock_model = create_strict_clock_model(), 
    site_model = create_jc69_site_model(),
    mcmc = create_mcmc()
  )
)
\end{lstlisting}

Experiments must be bundled in a list to work, even if only one is provided, as 
in this case:

\begin{lstlisting}[
  language = R, 
  floatplacement = ht,
  frame = single,
  label = {lst:create_gen_experiment},
  caption = {
    Create the experiments. In this case, we use only
    an experiment with the generative model,
    that will always be used in the actual inference.
  }
]
experiments <- list(generative_experiment)
\end{lstlisting}

We also need to specify the error measurement parameters $\mathit{E}$.
Here we choose the default $\mathit{E}$, which has a burn-in fraction 
of 10\% and uses the nLTT statistic to
measure the difference between phylogenies. For clarity,
we create this setup explicitly here:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_error_measure_params},
  caption = Calling \texttt{create\_error\_measure\_params}.
]
error_measure_params <- create_error_measure_params(
  error_fun = get_nltt_error_fun(),
  burn_in_fraction = 0.1
)
\end{lstlisting}

We now have all the needed \verb;pirouette; parameters: the alignment 
parameters, the experiments and the error measure parameters.
These objects need to be bundled in a larger parameter structure, 
using \verb;create_pir_params;:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_pir_params},
  caption = Calling \texttt{create\_pir\_params}.
]
pir_params <- create_pir_params(
  alignment_params = alignment_params,
  experiments = experiments,
  error_measure_params = error_measure_params
)
\end{lstlisting}

We can finally use the given Yule tree and \verb;pir_params; to measure the 
inference error made on phylogenies
created by a standard diversification model:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:pir_run},
  caption = Calling \texttt{pir\_run}.
]
errors <- pir_run(
  phylogeny = phylogeny,
  pir_params = pir_params
)
\end{lstlisting}

The error distribution can be plotted directly using \verb;pir_plot;:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:pir_plot},
  caption = Calling \texttt{pir\_plot}.
]
pir_plot(errors)
\end{lstlisting}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_1/example_1_314/errors.png}
  \caption{
    The inference error made 
    when the generative and inference models are the same.
    The vertical dashed line indicates the median error.
  }
  \label{fig:example_1}
\end{figure}

The resulting error distribution, as shown Figure~\ref{fig:example_1},
shows the inference error 
when $\mathit{I}$ matches with the generative model given 
by $\mathit{A}$ and $\mathit{p_{G}^0}$.
This error distribution can serve as a control,
as it is obtained from a tree of which the generating tree model is standard and known.
Obtaining this control is in fact an inherent part of \verb;pirouette;. 
We call it 'twinning' and we will demonstrate it in section
\ref{Comparing to background noise} below.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The inference model may differ from the generative model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In the previous example we selected the inference model $\mathit{I}$ to match 
with a known generative tree model $\mathit{p_{G}^0}$.
However, a novel tree prior $\mathit{p_{G}}$ is by (our) definition
non-standard, and hence not part of a standard inference 
model (i.e. an inference model using a standard tree prior).
In such a case, the question is which standard tree prior should be used in 
the inference. In this example, we do not only re-use our hand-picked 
inference model, but we also pick the best inference model from a set of 
inference models, i.e.  the model with 
the highest evidence measured by its marginal likelihood. 
We show the procedure using \verb;pirouette; to answer a second 
research question: "What is the inference error made on a novel phylogeny 
when using the best inference model, in comparison to a hand-picked model?

\begin{table}
  \begin{tabular}{ | c | c | c | l | }
    \hline
    \textbf{model\_type} &
    \textbf{run\_if} &
    \textbf{do\_measure\_evidence} & 
    \textbf{inference model} \\ 
    \hline
    generative & always         & FALSE & JC, strict, Yule \\
    candidate  & best candidate & TRUE  & JC, strict, BD   \\
    candidate  & best candidate & TRUE  & JC, strict, CBS  \\
    ...        & ...            & ...   & ...              \\
    candidate  & best candidate & TRUE  & GTR, RLN, CCP    \\
    candidate  & best candidate & TRUE  & GTR, RLN, CEP    \\
    \hline
  \end{tabular}
  \caption{
    Inference conditions and model.
    JC: Jukes-Cantor nucleotide substitution model.
    strict: strict clock model.
    Yule: Yule (pure-birth) tree prior.
    BD: birth-death tree prior.
    GTR: GTR nucleotide substitution model.
    RLN: relaxed log-normal clock model.
    CBS: coalescent Bayesian Skyline tree prior.
    CCP: coalescent constant-population tree prior.
    CEP: coalescent exponential-population tree prior.
  }
  \label{tab:RQ2}
\end{table}

We will use the same tree as generated in \ref{lst:create_yule_tree}, as well 
as the same alignment parameters as shown 
in Listing~\ref{lst:create_alignment_params}.

Here we specify a different set of experiments: we
need to state that we already have an experiment for
the generative model, as well as that we want all the other inference models 
to compete. We call the competing models 'candidate models'.
As model selection is commonly performed on the full list of available 
candidate models, \verb;pirouette; has a dedicated function 
for this choice: \verb;create_all_experiments; creates a full set 
of 40 experiments, 
containing the inference models of all combinations of 4 nucleotide substitution model, 
2 clock models and 5 tree priors. All we need to add is to exclude the 
inference model in the generative experiment:

\begin{lstlisting}[
  language = R, 
  floatplacement = ht, 
  frame = single, 
  label = {lst:create_all_experiments},
  caption = {
    Create all 40 candidate experiments, except for the inference model of the generative model.
  }
]
candidate_experiments <- create_all_experiments(
  exclude_model = generative_experiment$inference_model
)
\end{lstlisting}

We combine the generative and all the candidate models into one set of 
experiments:

\begin{lstlisting}[
  language = R, 
  floatplacement = ht, 
  frame = single, 
  label = {lst:combine_all_experiments},
  caption = {
    Create a collection of experiments, with 1
    generative model, and 39 candidate models.
  }
]
experiments <- c(
  list(generative_experiment),
  candidate_experiments
)
\end{lstlisting}

We can now create the complete \verb;pirouette; parameter set in the usual 
way (which is the same as Listing~\ref{lst:create_pir_params}, but using the 
defaults):

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_pir_params_defaults},
  caption = Create a \texttt{pir\_params} with many defaults.
]
pir_params <- create_pir_params(
  alignment_params = alignment_params,
  experiments = experiments
)
\end{lstlisting}

We run \verb;pirouette; (Listing~\ref{lst:pir_run}) 
and plot the results (Listing~\ref{lst:pir_plot}) in Figure~\ref{fig:example_2}.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_2/example_2_314/errors.png}
  \caption{
    The inference error for both generative and best candidate inference models.
    Vertical dashed lines show the median error value per distribution.
  }
  \label{fig:example_2}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The generative model is non-standard}\label{Comparing to background noise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

So far we have measured the inference error on a tree
generated according to a known (and standard) tree diversification model. 
The goal of \verb;pirouette; is to measure the expected impact of a novel tree prior.
To do so, in this example, we will use a tree generated by a non-standard 
tree diversification model, assumed to be closely related to the Yule tree prior.
We will use the diversity-dependent tree model \cite{DDD, etienne2011diversity},
which is a birth-death model with a speciation that is dependent on the
number of species.
We measure both the baseline 
error (that serves as a control) and the full inference error, because their 
difference shows the impact of the tree model.
We obtain the baseline error by using a twin tree (see Subsection~\ref{subsec:twinning}) for 
both the generative and best candidate models.
The research question this example answers is:
"What is the inference error made from a phylogeny, 
for both a generative model and the best candidate model?"

We start from the tree generated by a diversity-dependent model,
having six taxa and a crown age of ten:
\begin{lstlisting}[
  language = R, 
  floatplacement = ht,
  frame = single, 
  label = {lst:unknown_phylogeny},
  caption = A phylogeny generated by an unknown diversification model.
]
# NEW CODE HERE, 
# depends on https://github.com/richelbilderbeek/pirouette_article/issues/75
#
# phylogeny  <- ape::read.tree(
#   text = "(((A:8, B:8):1, C:9):1, ((D:8, E:8):1, F:9):1);"
# )
\end{lstlisting}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_3/example_3_314/true_tree.png}
  \caption{The tree derived from an unknown diversification process, 
    as created by listing~\ref{lst:unknown_phylogeny}.
    The scale overlaps with the lower branch, which is the default 
    behavior for the plotting function used.
  }
\end{figure}

Most of the other settings are the same as before: 
we reuse the alignment parameters (Listing~\ref{lst:create_alignment_params}), 
as well as the experiments (Listing~\ref{lst:create_all_experiments}).
This time, however, we enable twinning (see Subsection~\ref{subsec:twinning}),
by creating twinning parameters.
Creating these parameters is trivial with the default settings.
For clarity, however, we explicitly show the most important arguments:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_twinning_params},
  caption = Create the default twinning parameters.
]
twinning_params <- create_twinning_params(
  sim_twin_tree_fun = get_sim_bd_twin_tree_fun(),
  sim_twal_fun = get_sim_twal_with_std_nsm_fun()
)
\end{lstlisting}

We combine all the parameters using \verb;create_pir_params;:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_pir_params_with_twinning},
  caption = Create the default twinning parameters.
]
pir_params <- create_pir_params(
  alignment_params = alignment_params,
  experiments = experiments,
  twinning_params = twinning_params
)
\end{lstlisting}

We run \verb;pirouette; (Listing~\ref{lst:pir_run}) 
and plot the results (Listing~\ref{lst:pir_plot}).
The output is shown in Figure~\ref{fig:example_3}. 
While the error distributions using the best or generative model 
as inference model are very similar, 
the error distributions of the true tree are substantially 
larger than those of the twin tree. 
This is the error made by the mismatch
between the generating species tree model and the tree prior used in inference.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_3/example_3_314/errors.png}
  \caption{
    The inference error made 
    for both a generative tree prior and best candidate model
    compared with the error obtained for the twin tree.
    Here, the 'twin' tree shows the baseline inference error.
    Vertical dashed lines show the median error value per distribution.
  }
  \label{fig:example_3}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We showed how to use \verb;pirouette; to quantify the importance of a 
tree prior in Bayesian phylogenetics, using the simplest generative tree 
model possible.
In principle any other (more complex) generative tree model can be tested, 
but we chose to provide the simplest (and fastest to run) examples.

Figure~\ref{fig:example_3} illustrates the primary result of our pipeline: 
it shows the error distributions for the true tree and the twin tree 
when either the generating model or the best candidate model is used in inference. 
The clear difference between the error distributions 
for the true tree and the twin tree suggests 
that the choice of tree prior does matter.

We note, however, that all examples used only one original tree,
where any speciation process produces a whole range of trees.
One tree is not enough to determine the impact 
of a tree prior on Bayesian inference.
However, if the same procedure were repeated and 
performed on a distribution with a sufficient number of generative trees, 
it would constitute a quantitative and effective assessment of the 
quality of the inference.
Also a twin tree does not always result in a lower error distribution,
as the stochasticity in generating a twin tree will - with
very low probability - yield a tree of that same very low probability.

In conclusion, \verb;pirouette; can show the errors to be expected
when the tree prior used in inference is different from the generating model.
The user can then judge whether or not a new tree prior, 
tailored on the generative process, is needed. 
If this is indeed the case, one can implement the novel tree prior as an addition to 
his/her favorite Bayesian inference tool.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{pirouette resources}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; is free, libre and open source software available at 
\url{http://github.com/richelbilderbeek/pirouette},
licensed under the GNU General Public License version 3.
\verb;pirouette; depends on multiple packages, which are:
\verb;ape; (\cite{ape}),
\verb;babette; (\cite{bilderbeek2018babette}),
\verb;becosys; (\cite{becosys}),
\verb;DDD; (\cite{DDD}),
\verb;devtools; (\cite{devtools}),
\verb;dplyr; (\cite{dplyr}),
\verb;geiger; (\cite{geiger}),
\verb;ggplot2; (\cite{ggplot2}),
\verb;knitr; (\cite{knitr}),
\verb;lintr; (\cite{lintr}),
\verb;magrittr; (\cite{magrittr}),
\verb;mcbette; (\cite{mcbette}),
\verb;nLTT; (\cite{nLTT}),
\verb;PBD; (\cite{PBD}),
\verb;phangorn; (\cite{phangorn}),
\verb;phytools; (\cite{phytools}),
\verb;plyr; (\cite{plyr}),
\verb;rappdirs; (\cite{rappdirs}),
\verb;rmarkdown; (\cite{rmarkdown}),
\verb;Rmpfr; (\cite{Rmpfr}),
\verb;stringr; (\cite{stringr}),
\verb;TESS; (\cite{TESS}),
\verb;testit; (\cite{testit}), 
\verb;testthat; (\cite{testthat}) and
\verb;tidyr; (\cite{tidyr}).

\verb;pirouette;'s development takes place on GitHub,
\url{https://github.com/richelbilderbeek/pirouette},
which allows submitting bug reports, requesting features, 
and adding code. To ensure a high quality, \verb;pirouette; 
uses a continuous integration service, has a code coverage of above 95\%
and enforces the most commonly used R style guide (\cite{style_guide}).

\verb;pirouette;'s is extensively documented on its website,
its documentation and its vignettes.
The \verb;pirouette; website is a good starting point to learn
how to use \verb;pirouette;, as it links to tutorials and videos.
The \verb;pirouette; package documentation describes
all functions and liberally links to related functions.
All exported functions show a minimal example as part of their documentation.
The \verb;pirouette; vignette demonstrates extensively how 
to use \verb;pirouette; in a more informally written way. 

The code used in this article and more examples that are periodically 
tested, can be found at 
\url{https://github.com/richelbilderbeek/pirouette_examples}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Citation of pirouette}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To cite \verb;pirouette; this article from within R, use:

\begin{lstlisting}[language=R]
> citation("pirouette")
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We would like to thank the Center for Information Technology of the University 
of Groningen for its support and for providing access to the Peregrine 
high performance computing cluster. 
We thank the Netherlands 
Organization for Scientific Research (NWO) for financial support 
through a VICI grant awarded to RSE.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Accessibility}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

All code is archived at 
\url{http://github.com/richelbilderbeek/pirouette_article},
with DOI \url{https://doi.org/12.3456/zenodo.1234567}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authors' contributions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

RJCB, GL and RSE conceived the idea for the package. 
RJCB created, tested and revised the package.
GL provided major contributions to the package.
RJCB wrote the first draft of the manuscript, 
GL and RSE contributed to revisions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MEE style
\bibliographystyle{mee}
\bibliography{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

