\begin{abstract}

  \textbf{1. }
    Phylogenetic trees are current routinely reconstructed from an alignment 
    of character sequences (usually nucleotide sequences). 
    Bayesian tools, such as MrBayes, RevBayes and BEAST2, 
    have gained much popularity over the last decade, 
    as they allow joint estimation of the posterior distribution of the 
    phylogenetic trees and the parameters of the underlying inference model.  
    An important ingredient of these Bayesian approaches is the species tree 
    prior.
    \iffalse 
    While in principle the Bayesian framework allows for comparing 
    different species tree priors and hence may elucidate the macroevolutionary 
    processes underlying the species tree, in practice only 
    macroevolutionary models that allow for fast computation of the prior 
    probability are used. 
    \fi
    In principle the Bayesian framework allows for comparing different tree priors, which may elucidate the macroevolutionary processes underlying the species tree.
    In practice, however, only macroevolutionary models that allow for fast computation of the prior 
    probability are used.
    \iffalse
    An open question is, how accurate the tree estimation is when the real macroevolutionary processes are substantially different from those assumed in the tree prior. \\
    \fi
    It is still unclear how accurate is the tree estimation when the real \giovanni{People will ask what we mean with "real".} macroevolutionary processes are substantially different from those assumed in the tree prior. \\
    \textbf{2. }
    Here we present \verb;pirouette;, 
    a free, libre and open-source R package that assesses 
    the inference error made by Bayesian phylogenetics for a given 
    macroevolutionary diversification model. \verb;pirouette; makes use of 
    BEAST2, but its philosophy applies to any Bayesian phylogenetic inference 
    tool. \\
  \textbf{3. }
    We describe \verb;pirouette;'s usage and the biological scientific
    question it can answer, including full examples. \\
  \textbf{4. }
    Last, we discuss the results obtained by the examples and their 
    interpretation. \\
\end{abstract}

{\bf Keywords:} Bayesian model selection, BEAST2, computational biology, evolution, phylogenetics, R, tree prior

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The development of new powerful Bayesian phylogenetic inference tools, 
such as BEAST [\cite{drummond2007beast}], 
MrBayes [\cite{huelsenbeck2001mrbayes}]
or RevBayes [\cite{hohna2016revbayes}] 
has been a major advance in constructing phylogenetic trees 
from character data (usually nucleotide sequences) extracted 
from extant (but also extinct, where possible) organisms, and hence in our understanding of the main drivers 
and modes of diversification.

BEAST [\cite{drummond2007beast}] is a typical Bayesian phylogenetics tool, 
that needs both character data and priors to infer 
a posterior distribution of phylogenies.
Specifically, for the species tree prior - which describes 
the process of diversification - 
BEAST has built-in priors such as the Yule [\cite{yule}] and 
(constant-rate) birth-death [\cite{nee1994reconstructed}] models.
These simple tree priors are the most commonly used, as they have sufficient biological complexity, while being computationally fast.
BEAST's successor, BEAST2 [\cite{bouckaert2019beast}],
has a package manager, that allows third-party users 
to extend existing functionalities.
\iffalse
For example, one can add novel diversification models by writing a BEAST2 package that contains the likelihood formula of a phylogeny under the novel diversification model, i.e. the prior probability of a species tree.
\fi
For example, one can add a novel diversification model by implementing a BEAST2 package featuring a novel likelihood formula to assign a prior probability to the species tree, given model's macroevolutionary parameters.
\iffalse
Many diversification models (and their associated probability algorithms) have been developed, e.g., models in which diversification is time-dependent [\cite{nee1994reconstructed}, \cite{rabosky2008explosive}], 
or diversity-dependent [\cite{etienne2011diversity}],
or where diversification rates change for specific lineages 
and their descendants [\cite{etienne2012conceptual}, 
\cite{rabosky2014automatic}, \cite{alfaro2009nine}, 
\cite{laudanno2020sls}], models that treat speciation as a process that takes 
time [\cite{rosindell2010protracted}][\cite{etienne2012prolonging}][\cite{lambert2015reconstructed}], 
or as a burst of simultaneous branching
events [\cite{laudanno2018mbd}], or where diversification rate
depends on a trait that has two [\cite{maddison2007estimating}], 
or more [\cite{fitzjohn2012diversitree}] states,
even concealed states [\cite{beaulieu2016detecting}] 
or a combination of all these [\cite{herrera2018detecting}].
\fi
Many diversification models (and their associated probability algorithms) have been developed to account for possible mechanisms.
There are models in which diversification rates are time-dependent [\cite{nee1994reconstructed}, \cite{rabosky2008explosive}], 
or diversity-dependent [\cite{etienne2011diversity}],
or not homogeneous across the entire phylogeny [\cite{etienne2012conceptual}, 
\cite{rabosky2014automatic}, \cite{alfaro2009nine}, 
\cite{laudanno2020sls}], models that treat speciation as a process that takes time [\cite{rosindell2010protracted}][\cite{etienne2012prolonging}][\cite{lambert2015reconstructed}], 
or as a burst of simultaneous branching
events [\cite{laudanno2018mbd}].
Others account for trait-dependent regimes, in several ways: where diversification rates
depend on a trait that has two [\cite{maddison2007estimating}], 
or more [\cite{fitzjohn2012diversitree}] states,
even concealed states [\cite{beaulieu2016detecting}] 
or a combination of all these [\cite{herrera2018detecting}].
Despite such a rich theoretical landscape, only a few of these diversification models are available as a BEAST2 package.

When a novel diversification model is introduced,
its performance in inference should be tested.
Part of a model's performance is its ability to recover parameters from simulated data with known 
parameters (e.g. [\cite{etienne2014estimating}]), 
where ideally the estimated parameter values closely match the known/true values.

Even when a diversification model passes the procedure described above, it is not necessarily used in Bayesian inference.
Bayesian phylogenetic inference often requires 
that the prior probability of the phylogeny 
according to the diversification model has to be computed millions of times. 
Therefore, biologically interesting but computationally expensive tree priors 
are often not implemented, and simpler priors are used instead. 
This is not necessarily problematic, when the data are very informative, 
as this will reduce the influence of the tree prior.
However, the assumption that tree prior choice is of low importance must first be verified.

There have been multiple attempts to investigate the importance of tree
prior choice. For example, recently Sarver et al., [\cite{sarver2019choice}] 
showed that the choice of tree prior does not 
substantially affect phylogenetic inferences of diversification rates.
Also recently, Duchene et al. [\cite{duchene2018phylodynamic}] released
a BEAST2 package to assess how well posterior predictive simulations recover a given tree when using the standard diversification models.
These studies show how current diversification models compare to one another, but they do not help to assess 
the importance of a new tree prior. 

Here we introduce a method to quantify the importance of a novel tree prior.
The method starts with a phylogeny generated 
by the new model. 
Next, nucleotide sequences are simulated on \giovanni{from?} this phylogeny. 
Then,
\iffalse
using the tree priors built-in into BEAST2, 
\fi
using BEAST2's built-in tree priors,
a Bayesian posterior distribution of phylogenies is inferred. 
We then compare the inferred and simulated \giovanni{original?} phylogenies. 
How to properly perform this comparison forms the heart of our method.
Only new diversification models that result 
in a large discrepancy between inferred and simulated phylogenies will be worth the effort and computational burden to implement a species tree prior for in a Bayesian framework.

Our method is programmed as an R package (\cite{R}) called \verb;pirouette;.
\verb;pirouette; is built on \verb;babette; [\cite{bilderbeek2018babette}], 
which calls BEAST2 [\cite{bouckaert2019beast}]. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The goal of \verb;pirouette; is to quantify the importance of a tree prior.
It does so by measuring the inference error made 
for a given reconstructed phylogeny, 
simulated under a (usually novel) diversification model.
We refer to the true model that generated the given tree
as the 'generative tree model' $\mathit{p_{G}}$.
Many tree priors have a parameter setting 
for which they reduce to a standard tree prior. 
For example, a protracted birth-death model [\cite{etienne2012prolonging}] reduces to a standard birth-death model when the speciation-completion rate 
is infinite [i.e. rate $\lambda$ in \cite{etienne2014estimating}, 
eqs.~(2b) and (2c)].
When benchmarking a novel tree prior, 
one will typically construct phylogenies 
for different combinations of the diversification model's parameters, 
to assess under which scenarios the inference error cannot be neglected. 
While we recommend many replicate simulations 
when assessing a novel tree prior, 
our examples contain only one replicate 
as they are for illustrative purposes only. \giovanni{Is this true also for the post-review state of the manuscript?}

\verb;pirouette; is very flexible and allows the user 
to specify a wide variety of custom settings. 
These settings can be grouped in macro-sections, 
according to how they operate in the pipeline. 
We summarize them in Table~\ref{tab:options} and Table~\ref{tab:definitions}.
\giovanni{Pirouette has become very complex. A user might feel lost. What if we build a function to help the user to build the pir-params he or she needs? Maybe we can even program it in such a way the function asks direct questions to the user. If you think this could be a good idea I candidate to write a first version of such function.}

Although many possible tests can be performed, 
we show the usage of \verb;pirouette; by introducing 
its features gradually \giovanni{Is this true in the new version of the manuscript?}, yet ending in quantifying the impact a tree prior has in Bayesian inference.

\begin{sidewaystable}
\centering
  \begin{tabular}{|p{3.4cm}|p{9.7cm}|p{4.5cm}@{}|}
    \hline
    \centering
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \textbf{Sub-argument} & 
    \textbf{Description} &
    \textbf{Possible values} \\ 
    \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;tree_prior; &
    Macroevolutionary diversification model &
    BD, CBS, CCP, CEP, Yule \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;clock_model; &
    Clock for the DNA mutation rates &
    RLN, strict \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;site_model; &
    Nucleotide substitution model &
    GTR, HKY, JC, TN93 \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;mutation_rate; &
    Pace at which mutation occurs &
    \verb;mutation_rate; $\in \mathbb{R}_{>0}$\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;root_sequence; &
    DNA sequence at the root of the tree &
    any combination of a, c, g, t \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;model_type; &
    Criterion to select an inference model &
    Generative, Candidate \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;run_if; &
    Condition under which an inference model is used &
    Always, Best candidate \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;do_measure_evidence; &
    Sets whether or not the evidence of the model is to be computed &
    TRUE, FALSE \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;error_fun; &
    Specifies how to measure the error &
    nLTT, $|\gamma|$ \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \verb;burn_in_fraction; &
    Specifies the percentage of initial posterior trees to discard &
    \verb;burn_in_fraction; $\in [0, 1]$\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \hline
  \end{tabular}
  \caption{
    Most important parameter options.
    BD = birth death (\cite{nee1994reconstructed}), 
    CBS = coalescent Bayesian skyline (\cite{drummond2005bayesian}), 
    CCP = coalescent constant-population, 
    CEP = coalescent exponential-population,
    Yule = pure birth model (\cite{yule}),
    RLN = relaxed log-normal clock model (\cite{drummond2006relaxed}),
    strict = strict clock model (\cite{zuckerkandl1965molecules}), 
    GTR = Generalized time-reversible model (\cite{tavare1986some}), 
    HKY = Hasegawa, Kishino and Yano (\cite{hasegawa1985dating}), 
    JC = Jukes and Cantor (\cite{jukes1969evolution}), 
    TN93 = Tamura and Nei (\cite{tamura1993estimation}).
  }
  \label{tab:options}
\bigskip

  \begin{tabular}{|@{}c|p{4cm}|p{12.2cm}|}
    \hline
    \centering
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \textbf{Symbol} &
    \textbf{Macro-argument} &
    \textbf{Description} \\
    \hline
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{G}$ &
    Generative model &
    The full setting to produce BEAST2 input data. 
    Its core features are the tree prior $\mathit{p_{G}}$, the clock 
    model $\mathit{c_{G}}$ and the site model $\mathit{s_{G}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
    $\mathit{A}$ &
    Alignment model &
    It includes the parts of the generative model that directly affect the 
    alignment generation, like the clock model $\mathit{c_{G}}$ and 
    the site model $\mathit{s_{G}}$. Additional arguments can be provided, 
    such as the mutation rate and the root sequence. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{X_{i}}$ &
    $i$-th candidate experiment &
    Full setting for a Bayesian inference. It is made by a 
    candidate inference model $\mathit{I_{i}}$ and its 
    inference conditions $\mathit{C_{i}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{I}$ &
    Inference model &
    Phylogenetic inference model to run BEAST2. Likewise the generative model $G$, 
    its main components are the tree prior $\mathit{p_{I}}$, 
    the clock model $\mathit{c_{I}}$ and the site model $\mathit{s_{I}}$. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{C}$ & Inference conditions & Conditions under which $\mathit{I}$ 
    is used in the inference. 
    They are composed by the model type, run condition and 
    whether to measure the evidence. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    $\mathit{E}$ & Error measure parameters & 
    Errors measurement setup that can be specified providing an 
    error function to measure the difference between the original phylogeny 
    and the inferred posterior. The initial part of the posterior that is 
    reckoned as not representative can be discarded using a burn-in fraction. \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \iffalse
    $\mathit{T}$ & Twinning parameters & Twin tree creation procedure & 
      $\mathit{\tau_{p}}$ \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \fi
    \hline 
  \end{tabular}
  \caption{
    Definitions of terms and relative symbols used in the main text and in 
    Fig~\ref{fig:pipeline}. To run the pipeline $\mathit{A}$, $\mathit{X}$ 
    and $\mathit{E}$ must be specified. Examples can be found in 
    listings~\ref{lst:create_alignment_params}, 
    \ref{lst:create_gen_experiment_explicit} and 
    \ref{lst:create_error_measure_params}.
  }
  \label{tab:definitions}
\end{sidewaystable}

\subsection{pirouette's pipeline}
\label{subsec:pipeline}

\begin{figure}
  \centering
  \includegraphics[width = \textwidth]{workflow4.png}
  \caption{
    \texttt{pirouette} pipeline.
    The pipeline starts from a phylogeny (1a) simulated by the generative tree model 
    $\mathit{p_{G}}$.
    The phylogeny is converted to an alignment (2a) using the generative alignment model 
    $\mathit{A} = (\mathit{c_{G}}, \mathit{s_{G}})$, composed of a clock and a site model. 
    The user defines one or more experiments.
    For each candidate experiment $\mathit{X_{i}}$ 
    (a combination of inference model $\mathit{I_{i}}$ and condition $\mathit{C_{i}}$),
    if its condition $\mathit{C_{i}}$ is 
    satisfied (which can depend on the alignment), 
    the corresponding inference model $\mathit{I} = \mathit{I_{i}}$ is selected
    to be used in the next step.
    The inference models (3a) of the selected experiments use the alignment (2a) 
    to each create a Bayesian posterior of (parameter estimates and) 
    phylogenies (4a). 
    Each of the posteriors' trees is compared to the true phylogeny (1a) 
    using the error measure $\mathit{E}$, 
    resulting in an error distribution (5a). 
    Optionally, for each selected inference model a twin pipeline can be run.
    A twin phylogeny (1b) can be generated from the original 
    phylogeny (1a) using the twin tree model $\mathit{p_{t}}$, 
    selected among standard diversification models; 
    the default option is the standard birth-death model, with parameters estimated from the original phylogeny.
    A twin alignment (2b) is then simulated from the twin phylogeny 
    using clock model $\mathit{c_{G}}$ and site model $\mathit{s_{G}}$ 
    imported from the generative model. 
    The twin alignment has the same number of mutations as the original alignment.
    The twin pipeline follows the procedure of the main pipeline, 
    resulting in a twin error distribution (5b).
  }
  \label{fig:pipeline}
\end{figure}

We assume the user has a phylogeny simulated with the new diversification model.

\giovanni{long comment start}
A nice thing to do would be to exploit the novel pir\_runs function to create a wrapper that could work directly from the diversification model simulation function.

Something like this:
\begin{lstlisting}
sim_fun <- DDD::dd_sim
sim_pars <- list(
    pars1 = c(0.2, 0.1, 1.5, 0.1),
    age = 8
)
pir_paramses <- pirouette::create_pir_paramses(
    seeds = seeds,
    ...
)
seeds <- 1:100
pir_out <- pirouette::pir_run_from_sim_model(
    sim_model = sim_fun,
    sim_pars = sim_pars,
    pir_paramses = pir_paramses,
    seeds = seeds
)
\end{lstlisting}
In case you deem this is a good idea I candidate to write this function. Then you can test it and see if it works in a satisfying way.
\giovanni{long comment end}

The pipeline to assess the error BEAST2 makes in inferring this phylogeny 
then contains the following steps:
\begin{enumerate}
  \item from the given phylogeny an alignment is simulated 
    under a known alignment model $\mathit{A}$;
  \item from this alignment, according to the specified 
    inference conditions $\mathit{C}$, 
    an inference model $\mathit{I}$ is chosen (which may differ from the 
    generative model);
  \item the inference model and the alignment are used 
    to infer a posterior distribution of phylogenies;
  \item the phylogenies in the posterior are compared with the given phylogeny 
    to estimate the error made, according to 
    the error measure $\mathit{E}$ specified by the user;
\end{enumerate}
The pipeline is visualized in Fig.~\ref{fig:pipeline}. 
There is also the option to generate a 'twin tree', 
that goes through the same pipeline. 
The utility of this twin tree will be explained below.

The first step simulates a DNA alignment from a given 
phylogeny (Fig.~\ref{fig:pipeline}, 1a $\rightarrow$ 2a)
using the DNA alignment parameters.
The DNA alignment parameters consist of 
a (DNA) root sequence, a (DNA) mutation rate, a clock model 
and a nucleotide substitution model (which, for the sake of brevity, we will often refer to as "site model").
The root sequence is the DNA sequence of the shared common ancestor,
and is set to four different equally-sized mononucleotide blocks by default, as this
helps interpreting the resulting alignment.
Supported nucleotide substitution models
are JC, HKY, TN and GTR. Only the strict
clock model is currently supported in this step.

The second step (Fig.~\ref{fig:pipeline}, 3a)
selects one (or more) inference model(s) $I$ from a set of inference models $I_{1},\dots,I_{n}$. 
We define an experiment $X_{i}$ as the combination of 
an inference model $I_{i}$ and the conditions $C_{i}$ 
to actually use it in the inference step.
For example, we may require that an inference
model (a combination of a tree model, clock model and site model) 
should include the generative/true tree model. 
As a second example, we may require that we have selected a set of 
candidate inference models,
of which only the best should be used in the actual inference.
In the first example, we specified the condition $C_{i}$ that this
generative model should always be run, whereas in the second example,
we specified condition $C_{i}$ that a candidate model should only be run
when it is the best.
The 'best' model is defined as the inference model with
the highest evidence (a.k.a. marginal likelihood), given the alignment 
simulated in the previous step.
The evidence for an inference model is estimated by nested 
sampling [\cite{russel2019model}], using the \verb;NS; BEAST2 package. 
We note that scripted use of BEAST2 packages is only possible under Linux and Mac.
Windows systems can do the model comparison for shorter DNA sequences 
using the web interface of \verb;mcbette; [\cite{mcbette}].

The third step infers the posterior distributions,
using the simulated alignment (Fig.~\ref{fig:pipeline}, 2a $\rightarrow$ 4a),
and the inference models that were selected in the previous step (3a). 
For each selected experiment a posterior distribution is inferred, using the 
\verb;babette; [\cite{bilderbeek2018babette}] R package which makes use of BEAST2. 
This step usually takes up most of the pipeline's computation time.

The fourth step quantifies the inference error made. 
First the burn-in fraction is removed, i.e. the first phase of the 
Markov chain Monte Carlo (MCMC) run,
which samples an unrepresentative part of state space. 
By default, \verb;pirouette; 
removes the first 10\% of the posterior.
From the remaining posterior \verb;pirouette; 
creates an error distribution, by measuring the difference
between the true tree and each of the posterior 
trees (Fig.~\ref{fig:pipeline}, 4a $\rightarrow$ 5a).
The user can specify a function to quantify the differences between
the true and posterior trees. By default, the package uses the nLTT 
statistic (\cite{janzen2015approximate}), which is the absolute difference
between the normalized lineages-through-time plots of two trees.

\subsection{Twinning}\label{subsec:twinning}

An optional step is to use the 'twinning process'.
This process, $T$, encompasses two steps:
$T_1$, that generates a 'twin tree' (Fig.~\ref{fig:pipeline}, 1b) 
and $T_2$, which generates a 'twin alignment' (Fig.~\ref{fig:pipeline}, 2b).
Both twin tree and alignment will be analyzed in the same way 
as the true tree and alignment.

We define a phylogeny $\tau$ as the combination of
branching times $\Vec{t}$ and topology $\psi$, 
and denote as $\tau_{\mathit{G}}$ the phylogeny 
produced by a (possibly non-standard) generative diversification model, 
having branching times $\Vec{t}_{\mathit{G}}$ and 
topology $\psi_{\mathit{G}}$.

The first step ($T_1$) of the twinning process creates a tree $\tau_{\mathit{T}}$
with branching times $\Vec{t}_{\mathit{T}}$ while preserving the original
topology $\psi_{\mathit{G}}$:
\begin{align}
  \tau_{\mathit{G}} = (\Vec{t}_{\mathit{G}}, \psi_{\mathit{G}}) 
  \xrightarrow[]{\mathit{T_1}} 
  \tau_{\mathit{T}} = (\Vec{t}_{\mathit{T}}, \psi_{\mathit{G}})
\end{align}
The default option for the diversification model $p_T$ is the standard birth-death model.
It is then possible to use the likelihood function 
$L_{\mathit{T}}$ for this diversification model to find the parameters $\theta^{*}_{\mathit{T}}$ 
(e.g. speciation and extinction rates, in case of a birth-death model) 
that maximize this likelihood applied 
to the true tree, conditioned on its number of tips $n_{\mathit{G}}$:
\begin{align}
    \max[L_{\mathit{T}}(\theta_{\mathit{T}}|\tau_{\mathit{G}}, n_{\mathit{G}})] 
\rightarrow \theta^{*}_{\mathit{T}}.
\end{align}
We use $\theta^{*}_{\mathit{T}}$ to simulate a number 
$n_{\mathit{T}} = n_{\mathit{G}}$ 
of branching times $\Vec{t}_{\mathit{T}}$ for the twin tree 
$\tau_{\mathit{T}}$, under the process $p_{T}$, 
while preserving the topology. We simulate the new branching times using the TESS package (\cite{TESS, hohna2016tess}).

The second step ($T_2$) of the twinning process simulates the twin alignment 
with the same clock model, site model and mutation rate 
used to simulate the original alignment. 
We also impose that, in the twin alignment, 
the total number of mutations with respect to the root sequence 
must be the same as in the true alignment in order to keep the information content 
stored in both the true and twin alignments as similar as possible. We achieve this by simply simulating twin alignments until we
obtain one that has the desired number of mutations.

The twin pipeline serves as a control: 
even when the generating and inference models are identical
(as is the case in the twin pipeline),
the inferred trees from the posterior distribution will 
still differ from the true tree, 
due to stochasticity in producing an alignment 
and to the MCMC sampling of the posterior.
The twin pipeline provides this minimum error,
because the generating and inference model match exactly.
When comparing the true and twin error distribution,
any differences will be due to the fact that true and twin phylogenies are realizations 
of different processes: one (possibly) non-standard, $p_G$, 
and one standard, $p_T$ (see Fig~\ref{fig:pipeline}).

This can be seen for both the "generative" and "candidate" model 
types (see Table~\ref{tab:options}).
If the chosen model type is "generative", 
the tree prior chosen for the twin inference will  
exactly match the model to generate the tree.
In the main pipeline, as the tree model $p_{G}$ is non-standard, 
it cannot be used in inference.
If, instead, the chosen model type is "candidate", 
the twin tree model will be included in the pool of examined models 
during the process of selection of the inference model. 

Finally, if the goal is to evaluate BEAST2's performance on a non-standard tree prior, 
the last source of stochasticity comes from phylogenies. 
In fact, a single phylogeny cannot be considered 
as fully representative of the model. 
For this reason multiple phylogenies, 
as well as an equal number of twins, 
must be considered. 
Having the error measure normalized (i.e. comprised in the interval $[0, 1]$), 
it is possible to considerate the aggregated versions of the errors distributions 
across all the runs.
Therefore, if the number of considered phylogenies is high enough, 
the comparison between the main pipeline's aggregated error distribution 
and its twin counterpart leads to a fair evaluation 
of the new tree prior with respect to the baseline error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; will be made available on CRAN from which 
it can then be easily installed:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install.packages("pirouette")
\end{lstlisting}

Until it is on CRAN, and for the most up-to-date version, 
one can download and install the package from \verb;pirouette;'s GitHub 
repository:

\begin{lstlisting}[
    language = R,
    floatplacement = ht,
    frame = single
]
remotes::install_github("richelbilderbeek/pirouette")
\end{lstlisting}
To start using \verb;pirouette;, 
load its functions in the global namespace first:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
library(pirouette)
\end{lstlisting}
Because \verb;pirouette; calls BEAST2, BEAST2 must be installed. 
This can be done from within R, using:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install_beast2()
\end{lstlisting}
For the option to select the best candidate model,
\verb;pirouette; needs the "NS" BEAST2 package [\cite{russel2019model}].
It can be installed from within R, using:
\begin{lstlisting}[language=R, floatplacement=ht, frame=single]
install_beast2_pkg("NS")
\end{lstlisting}

An overview of \verb;pirouette;'s main functions is shown in 
Table~\ref{tab:functions}. 
Their usage is demonstrated in the example code below.
All \verb;pirouette;'s functions are documented,
have a useful example and sensible defaults.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[h]
  \centering
  \begin{tabular}{ | l | l | l | }
    \hline
    \textbf{Name} & \textbf{Description} & \textbf{Listing} \\
    \hline
    \verb;pir_run; & Run \verb;pirouette; & \ref{lst:pir_run} \\
    \verb;pir_plot; & Show the \verb;pirouette; results as a plot & \ref{lst:pir_plot} \\
    \verb;create_pir_params; & Create the \verb;pirouette; parameters & \ref{lst:create_pir_params} \\
    \hline
    \verb;create_alignment_params; & Create the alignment parameters & \ref{lst:create_alignment_params} \\
    \verb;create_twinning_params; & Create the twinning parameters & \ref{lst:create_twinning_params} \\
    \verb;create_experiment; & Create one experiment & \ref{lst:create_gen_experiment_explicit} \\
    \verb;create_error_measure_params; & Create the error measurement parameters & \ref{lst:create_error_measure_params} \\
    \hline
  \end{tabular}
  \caption{
    \texttt{pirouette}'s main functions, description and the number of the 
    listing in which it is used. 
  }
  \label{tab:functions}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Usage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We show the usage of \verb;pirouette; on an tree generated by a non-standard 
tree model \richel{code at \url{https://github.com/richelbilderbeek/pirouette_example_30}}. 
We use the diversity-dependent tree model \cite{DDD, etienne2011diversity},
which is a birth-death model with a speciation rate that is dependent on the
number of species. 

We choose to use a small tree with six taxa, to keep
the calculations short and the figure more readable.
We pick a crown age of ten time units. This value is 
completely arbitrary, but it ties in with the mutation rate 
used in simulating an alignment in the next step.

\begin{lstlisting}[
  language = R, 
  floatplacement = ht,
  frame = single, 
  label = {lst:create_dd_tree},
  caption = A phylogeny generated by an unknown diversification model.
]
phylogeny <- create_dd_tree(n_taxa = 6, crown_age = 10)
\end{lstlisting}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_30/example_30_314/true_tree.png}
  \caption{
    The tree derived from a DD process, 
    as created by listing~\ref{lst:create_dd_tree}.
  }
\end{figure}

The first step in \verb;pirouette; is to simulate a DNA alignment from the 
given phylogeny, as described in Subsection~\ref{subsec:pipeline}.
In this example, the root sequence consists of four blocks of 250 
mononucleotides each, while the per-nucleotide mutation rate is 
0.1 mutations per unit time.
We use a Jukes-Cantor (JC, \cite{jukes1969evolution}) nucleotide substitution model
and a strict clock model as these are the simplest.
A JC model assumes that mutation rates between nucleotides are equal and 
constant. 
A strict clock model assumes that the mutation rates 
of all lineages are equal and constant.

\begin{lstlisting}[
    language = R,
    floatplacement = ht,
    frame = single,
    label = {lst:create_alignment_params}, 
    caption = {Create an alignment.}
  ]
alignment_params <- create_alignment_params(
  sim_tral_fun = get_sim_tral_with_std_nsm_fun(
    mutation_rate = 0.1,
    site_model = create_jc69_site_model()
  ),
  root_sequence = create_blocked_dna(length = 1000)
)
\end{lstlisting}

As the site and clock models used here are also the defaults, 
the function arguments can be safely omitted: we just explicitly show 
them for the sake of clarity.

In the second step we state our experiment.
We define an experiment $\mathit{X}$ as a combination of an inference model 
$\mathit{I}$ and conditions $\mathit{C}$.
In this example we choose $\mathit{I}$ to be the same inference model as 
the generative one,
i.e. the Yule tree prior $\mathit{p_{G}^0}$ and site 
and clock models defined in $\mathit{A}$, 
respectively Jukes-Cantor and strict clock.
We specify in $\mathit{C}$ that the experiment will always be run.

\begin{table}
  \begin{tabular}{ | c | c | c | l | }
    \hline
    \texttt{model\_type} &
    \texttt{run\_if} &
    \texttt{do\_measure\_evidence} & 
    \texttt{inference model} \\ 
    \hline
    generative &
    always &
    FALSE &
    JC, strict, Yule \\
    \hline
  \end{tabular}
  \caption{
    Inference conditions and model.
    JC: Jukes-Cantor nucleotide substitution model.
    strict: strict clock model.
    Yule: Yule (pure-birth) tree prior.
  }
  \label{tab:RQ1}
\end{table}

Listing~\ref{lst:create_gen_experiment_explicit} shows how to
set up this experiment:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_gen_experiment_explicit},
  caption = {
    Create an experiment with the generative model,
    that will always be used in the actual inference, 
    using explicit arguments.
  }
]
generative_experiment <- create_experiment(
  inference_conditions = create_inference_conditions(
    model_type = "generative", 
    run_if = "always"
  ), 
  inference_model = create_inference_model(
    tree_prior = create_yule_tree_prior(),
    clock_model = create_strict_clock_model(), 
    site_model = create_jc69_site_model(),
    mcmc = create_mcmc()
  )
)
\end{lstlisting}

Here we specify a different set of experiments: we
need to state that we already have an experiment for
the generative model, as well as that we want all the other inference models 
to compete. We call the competing models 'candidate models'.
As model selection is commonly performed on the full list of available 
candidate models, \verb;pirouette; has a dedicated function 
for this choice: \verb;create_all_bd_experiments; creates a full set 
of 16 experiments, 
containing the inference models of all combinations of 4 nucleotide substitution model, 
2 clock models and 2 birth-death tree priors. All we need to add is to exclude the 
inference model in the generative experiment:

\begin{lstlisting}[
  language = R, 
  floatplacement = ht, 
  frame = single, 
  label = {lst:create_all_experiments},
  caption = {
    Create all 16 candidate experiments, 
    except for the inference model of the generative model.
  }
]
candidate_experiments <- create_all_bd_experiments(
  exclude_model = generative_experiment$inference_model
)
\end{lstlisting}

We combine the generative and all the candidate models into one set of 
experiments:

\begin{lstlisting}[
  language = R, 
  floatplacement = ht, 
  frame = single, 
  label = {lst:combine_all_experiments},
  caption = {
    Create a collection of experiments, with 1
    generative model, and 15 candidate models.
  }
]
experiments <- c(
  list(generative_experiment),
  candidate_experiments
)
\end{lstlisting}

We also need to specify the error measurement parameters $\mathit{E}$.
Here we choose the default $\mathit{E}$, which has a burn-in fraction 
of 10\% and uses the nLTT statistic to
measure the difference between phylogenies. For clarity,
we create this setup explicitly here:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_error_measure_params},
  caption = Calling \texttt{create\_error\_measure\_params}.
]
error_measure_params <- create_error_measure_params(
  error_fun = get_nltt_error_fun(),
  burn_in_fraction = 0.1
)
\end{lstlisting}

We now have all the needed \verb;pirouette; parameters: the alignment 
parameters, the experiments and the error measure parameters.


Next, we enable twinning (see Subsection~\ref{subsec:twinning}),
by creating twinning parameters.
Creating these parameters is trivial with the default settings.
For clarity, however, we explicitly show the most important arguments:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_twinning_params},
  caption = Create the default twinning parameters.
]
twinning_params <- create_twinning_params(
  sim_twin_tree_fun = get_sim_bd_twin_tree_fun(),
  sim_twal_fun = get_sim_twal_with_std_nsm_fun()
)
\end{lstlisting}

We combine all the parameters using \verb;create_pir_params;:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:create_pir_params_with_twinning},
  caption = Create the default twinning parameters.
]
pir_params <- create_pir_params(
  alignment_params = alignment_params,
  experiments = experiments,
  twinning_params = twinning_params
)
\end{lstlisting}

We can finally use the DD tree and \verb;pir_params; to measure the 
inference error made on phylogenies
created by a standard diversification model:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:pir_run},
  caption = Calling \texttt{pir\_run}.
]
errors <- pir_run(
  phylogeny = phylogeny,
  pir_params = pir_params
)
\end{lstlisting}

The error distribution can be plotted directly using \verb;pir_plot;:

\begin{lstlisting}[
  language = R,
  floatplacement = ht,
  frame = single,
  label = {lst:pir_plot},
  caption = Calling \texttt{pir\_plot}.
]
pir_plot(errors)
\end{lstlisting}

\begin{figure}[H]
  \includegraphics[width=\textwidth]{pirouette_example_30/example_30_314/errors.png}
  \caption{
    The inference error made 
    for both a generative tree prior and best candidate model
    compared with the error obtained for the twin tree.
    Here, the 'twin' tree shows the baseline inference error.
    Vertical dashed lines show the median error value per distribution.
  }
  \label{fig:example_30}
\end{figure}

While the error distributions using the best or generative model 
as inference model are very similar, 
the error distributions of the true tree are substantially 
larger than those of the twin tree. 
This is the error made by the mismatch
between the generating species tree model and the tree prior used in inference.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We showed how to use \verb;pirouette; to quantify the importance of a 
tree prior in Bayesian phylogenetics, using the simplest generative tree 
model possible.
In principle any other (more complex) generative tree model can be tested, 
but we chose to provide the simplest (and fastest to run) examples.

Figure~\ref{fig:example_3} illustrates the primary result of our pipeline: 
it shows the error distributions for the true tree and the twin tree 
when either the generating model or the best candidate model is used in inference. 
The clear difference between the error distributions 
for the true tree and the twin tree suggests 
that the choice of tree prior does matter.

We note, however, that all examples used only one original tree,
where any speciation process produces a whole range of trees.
One tree is not enough to determine the impact 
of a tree prior on Bayesian inference.
However, if the same procedure were repeated and 
performed on a distribution with a sufficient number of generative trees, 
it would constitute a quantitative and effective assessment of the 
quality of the inference.
Also a twin tree does not always result in a lower error distribution,
as the stochasticity in generating a twin tree will - with
very low probability - yield a tree of that same very low probability.

In conclusion, \verb;pirouette; can show the errors to be expected
when the tree prior used in inference is different from the generating model.
The user can then judge whether or not a new tree prior, 
tailored on the generative process, is needed. 
If this is indeed the case, one can implement the novel tree prior as an addition to 
his/her favorite Bayesian inference tool.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{pirouette resources}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\verb;pirouette; is free, libre and open source software available at 
\url{http://github.com/richelbilderbeek/pirouette},
licensed under the GNU General Public License version 3.
\verb;pirouette; depends on multiple packages, which are:
\verb;ape; (\cite{ape}),
\verb;babette; (\cite{bilderbeek2018babette}),
\verb;becosys; (\cite{becosys}),
\verb;DDD; (\cite{DDD}),
\verb;devtools; (\cite{devtools}),
\verb;dplyr; (\cite{dplyr}),
\verb;geiger; (\cite{geiger}),
\verb;ggplot2; (\cite{ggplot2}),
\verb;knitr; (\cite{knitr}),
\verb;lintr; (\cite{lintr}),
\verb;magrittr; (\cite{magrittr}),
\verb;mcbette; (\cite{mcbette}),
\verb;nLTT; (\cite{nLTT}),
\verb;PBD; (\cite{PBD}),
\verb;phangorn; (\cite{phangorn}),
\verb;phytools; (\cite{phytools}),
\verb;plyr; (\cite{plyr}),
\verb;rappdirs; (\cite{rappdirs}),
\verb;rmarkdown; (\cite{rmarkdown}),
\verb;Rmpfr; (\cite{Rmpfr}),
\verb;stringr; (\cite{stringr}),
\verb;TESS; (\cite{TESS}),
\verb;testit; (\cite{testit}), 
\verb;testthat; (\cite{testthat}) and
\verb;tidyr; (\cite{tidyr}).

\verb;pirouette;'s development takes place on GitHub,
\url{https://github.com/richelbilderbeek/pirouette},
which allows submitting bug reports, requesting features, 
and adding code. To ensure a high quality, \verb;pirouette; 
uses a continuous integration service, has a code coverage of above 95\%
and enforces the most commonly used R style guide (\cite{style_guide}).

\verb;pirouette;'s is extensively documented on its website,
its documentation and its vignettes.
The \verb;pirouette; website is a good starting point to learn
how to use \verb;pirouette;, as it links to tutorials and videos.
The \verb;pirouette; package documentation describes
all functions and liberally links to related functions.
All exported functions show a minimal example as part of their documentation.
The \verb;pirouette; vignette demonstrates extensively how 
to use \verb;pirouette; in a more informally written way. 

The code used in this article and more examples that are periodically 
tested, can be found at 
\url{https://github.com/richelbilderbeek/pirouette_examples}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Citation of pirouette}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To cite \verb;pirouette; this article from within R, use:

\begin{lstlisting}[language=R]
> citation("pirouette")
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Acknowledgments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We would like to thank the Center for Information Technology of the University 
of Groningen for its support and for providing access to the Peregrine 
high performance computing cluster. 
We thank the Netherlands 
Organization for Scientific Research (NWO) for financial support 
through a VICI grant awarded to RSE.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Accessibility}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

All code is archived at 
\url{http://github.com/richelbilderbeek/pirouette_article},
with DOI \url{https://doi.org/12.3456/zenodo.1234567}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Authors' contributions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

RJCB, GL and RSE conceived the idea for the package. 
RJCB created, tested and revised the package.
GL provided major contributions to the package.
RJCB wrote the first draft of the manuscript, 
GL and RSE contributed to revisions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MEE style
\bibliographystyle{mee}
\bibliography{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

